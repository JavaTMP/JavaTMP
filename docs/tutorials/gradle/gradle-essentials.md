---
title: Gradle Essentials
---
# {{ page.title }}

Building a software artifact is a complex process involving various activities such as compiling source code,
running automated tests, packaging distributable files, and so on.
These activities are further split into many steps, often dependent on the execution order, fetching dependent artifacts,
resolving configuration variables, and so on.
Executing all these activities manually is cumbersome and often error-prone.
A good build automation tool helps us reduce the effort and time it takes to build correct artifacts in a repeatable manner.

## Introduction

### Gradle is
- an advanced build automation tool that brings the best from various proven build tools and innovates on top of them.
- can be used to produce different kind of artifacts such as web applications, static sites, and desktop applications.
- Works by conventions over configuration.
- can be configured using very human-friendly Groovy DSL.

### Installing Gradle
- Gradle needs Java Runtime Environment (JRE) 6 or Java Development Kit (JDK) 1.6 or higher.
- Download page is https://gradle.org/install/
- Gradle User Manual is https://docs.gradle.org/current/userguide/userguide.html
- Export or add Environment Variables to your OS to run gradle from any command line shell.
- Verifying the installation by `gradle --version` or `gradle -v`
- In case we need to set some global options for the JVM that Gradle will use,
we can set the `GRADLE_OPTS` environment variable with acceptable flags to tune the JVM.
- Gradle also honors the `JAVA_OPTS` environment variable. but his affects the setting for all the Java programs on a machine.

### The Gradle command-line interface
- `gradle` command is issued from the root of a project directory with some tasks to be executed. like `gradle help`
- Gradle tasks may vary depending on the project in which the gradle command is being run.
- Gradle tasks are currently available on project by `gradle tasks` command.

### Gradle build script
- Gradle treats the current directory as a project root and tries to find the build.gradle file there.
- Create and open the `build.gradle` file and declare a task by adding the following line `task helloWorld`
- Task helloWorld and run it using command `gradle -q helloWorld`:
```
task helloWorld {
    println "Hello, World!"
    println ("Hello, World!")
    println ("Hello, World!");
    System.out.println("Hello, World!")
    System.out.println("Hello, World!");
    System.out.println "Hello, World!";
    System.out.println "Hello, World!"
}
```

- While calling a gradle task from a command line, we can save a few keystrokes by typing only
the characters that are enough to uniquely identify the task name. For example,
the task helloWorld can be called using gradle hW. We can also use helloW, hWorld, or even heWo
- Gradle Daemon is a process that keeps running in the background to speed up the builds significantly.

### Gradle Wrapper
- A Gradle Wrapper consists of a `gradlew` shell script for Linux/Mac OS X,
a `gradlew.bat` batch script for Windows, and a few helper files.
- These files can be generated by running a `gradle wrapper` task
and should be checked into the version control system (VCS) along with project sources.
Instead of using the system-wide gradle command, we can run the builds via the wrapper script.
- the advantages of running builds via a wrapper script are
    - We don’t need to download and install Gradle manually. The wrapper script takes care of this.
    - It uses a specific version of Gradle that the project needs.
- To generate the wrapper scripts and supporting files, just execute the following code from the command line:
`gradle wrapper` or `gradle wrapper --gradle-version 5.0`
- To running a build via wrapper use it like any other command `gradlew helloWorld`
and we can use the arguments and flags exactly in the same way as we pass to the gradle command.

## Building Java Projects
- In the root of the project directory create the `build.gradle` file and add the following code line to it:

```java
apply plugin: 'java'
```

- Adding source files in the same structure for any standard maven project in `src/main/java` directory.
- To compile the project and produce the class files call the following task from a command line: `gradle compileJava`
and the compiled classes go into `build/classes/main` relative to the project root.
- To generate the `.jar` file for our application run the following task: `gradle build`
and the jar will be in the `build/libs` directory.
- Note that when we run the `build` task, Gradle also invokes the `compileJava` and other dependent tasks
before actually executing the build task. So, we don't need to explicitly call `compileJava` here to compile classes.
- The name of the .jar file is the same as that of the project.
This can be configured by setting the `archivesBaseName` property in the build.gradle file. as

```java
archivesBaseName = "my-app"
```

- To see what all tasks were brought into our build by the java plugin run `gradle –q tasks` command.
- Gradle by itself is nothing more than a task runner. It does not know how to compile a Java file
or where to read the source files. It means that these tasks are not there by default.
and a Gradle build file, without any plugin applied, contained very few tasks.
- A plugin adds relevant tasks and conventions to a Gradle build.
all the tasks such as compileJava, build, clean, and many more are essentially brought in by the java plugin
that we applied to our build.
- There are number of plugins that come out of the box with Gradle. The `java` plugin is one such plugin.

### Unit testing
- Java test sources are kept in the `src/test/java` directory relative to the project root.
- To compile tests use the `compileTestJava` task, which is exactly the same as `compileJava`, but compiles the test source files.

#### Adding the JUnit to the classpath
- we need JUnit library on the classpath. And this dependency is only required
while compiling and running the tests.
- In the dependencies section, we list down all the dependencies of the project along with their scope.
We declared JUnit to be made available in the testCompile scope.
- In the repositories section, we configure the type and location of the repository where external dependencies will be found.
- We need to update the build.gradle file as follows:

```java
apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    testCompile 'junit:junit:4.12'
}
```

- Running the test by command `gradle test`
- Whether the test passes or not, a nice HTML report is created with details of all the tests that are run.
By default, this report is located at build/reports/tests/index.html relative to the project root.
- We just need to call the last task in the flow, and all the tasks that the called tasks depend on will be called sequentially
and the build will not succeed if any of the tasks fails.
- If we need to force run task actions even if nothing has changed between the two runs,
we can pass the `--rerun-tasks` flag on the command line so that all task actions can run.

### Bundling an application distributable
- applies the `application` plugin to our build by `apply plugin: 'application'`
- Add `mainClassName` and `run.args` attributes.
- The `application` plugin adds the `run` task to our build.
- as we are applying the application plugin, it is not necessary to explicitly apply the java plugin
as an application plugin implicitly applies the java plugin to our build.
- It also implicitly applies the distribution plugin so that we get the tasks to package the application
as a ZIP or TAR archive and also gets the task to install the application distribution locally.
- More information on the application plugin can be found at https://docs.gradle.org/current/userguide/distribution_plugin.html.
- Running the application with Gradle by `gradle run` or `gradle -q run`.
- The –P adds properties to the Gradle Project. like `gradle -q run -PrunArgs=world` and access it by `project.runArgs`.
- We could create a gradle.properties in project’s root parallel to the build.gradle file.
- There are ways to declare properties which can be found at https://docs.gradle.org/current/userguide/build_environment.html.

#### Building the distribution archive

- Another interesting task is `distZip`, which packages the application along with OS-specific start scripts: `gradle distZip`.
- It would have generated the application distribution in ZIP format in the build/distributions relative to the project root.
- The name of the ZIP defaults to the project name. unless change by using the following property in build.gradle: `distributions.main.baseName = 'someName'`
- unzip the archive to see its contents and folders structure.

### Generating IDE project files
- Gradle sports very nice plugins that can generate IDE-specific project files.
Both IntelliJ IDEA and Eclipse are covered by their respective plugins.
Depending on which IDE you want to support, you will either include `apply plugin: 'idea'` or `apply plugin: 'eclipse'`.
- execute the following for Eclipse and IntelliJ IDEA, respectively:

```
$ gradle eclipse
$ gradle idea
```

- Make sure you ignore IDE-specific files in version control. For example, if you are using Git,
consider adding the following entries in your .gitignore file to prevent someone from accidentally committing
the IDE-specific files:

```
.idea/
*.iml
*.ipr
*.iws
.classpath
.project
.settings/
```

## Building a Web Application

- To create the `build.gradle` file for Building a Web Application in the root of the project:

```java
apply plugin: 'war'

repositories {
    mavenCentral()
}

dependencies {
    providedCompile 'javax.servlet:javax.servlet-api:3.1.0'
}
```

- The war plugin extends the java plugin; so all the tasks that were available when we applied the java plugin are still available
to us in addition to the war task.
- the `providedCompile` configuration (scope) tells Gradle not to package the servlet API with the application,
as it will already be available on the container where the application will be deployed.
The `providedCompile` configuration is added by the `war` plugin (it also adds `providedRuntime`).
- To build the deployable WAR file. use command `gradle war`.
- To verify the tasks available for our build use command `gradle tasks --all`.
- The war file is created at `/build/libs/hello-web.war`.
- To list the contents of WAR, use `jar -tf build/libs/hello-web.war` or use any the standard zip/unzip tools.
- When we say build automation, it implicitly means that no manual intervention should be expected
and things should work in one click (or one command in Gradle's case).
- Gradle plugins like a `Gretty` plugin can be found at a Gradle plugin portal,
This plugin adds numerous tasks to the build and supports various versions of Tomcat and Jetty.
- To configure it use:

```
plugins {
    id "org.akhikhl.gretty" version "2.0.0"
}
```

- We can include the `war` plugin's application inside this block. For internal plugins,
we don't need to specify a version. It will look as follows:

```
plugins {
    id "org.akhikhl.gretty" version "1.2.4"
    id "war"
}
```

- If we run gradle tasks now, we must have an appRun task under the Gretty group.
There are many more tasks in this group, which are added by the Gretty plugin.
- There are many configurations exposed by the plugin, in order to control aspects such as server version, port number,
and many more. Add a gretty block to the build.gradle files as follows:

```
gretty {
    servletContainer = 'tomcat8'
    port = 8080
}
```

or

```
gretty {
    servletContainer = 'jetty9'
    port = 9080
}
```

- Important Reference Links:
    - Gradle plugin portal: https://plugins.gradle.org/
    - Tomcat plugin: https://github.com/bmuschko/gradle-tomcat-plugin

### Project dependencies
- Gradle locates and makes dependencies available in the appropriate classpath and packaging if required.

#### External libraries
- The dependencies of a project are declared in the `dependencies` section in the build file.
- the coordinates of an Gradle dependency artifact takes a form of group:name:version. like:

```
dependencies {
    compile 'org.springframework:spring-core:4.0.6.RELEASE'
    compile group:'org.springframework', name:'spring-core', version:'4.0.6.RELEASE'
}
```

- We can also specify multiple dependencies as follows: `configurationName dep1, dep2, dep3,...`
- We run the following code in our build.gradle file: `runtime 'org.slf4j:slf4j-nop:1.7+'` to indicate a dynamic version of the library.
- run the dependencies task by : `gradle dependencies`
- Gradle resolves transitive dependencies quite well.
- To disable Gradle transitive dependencies provide an extra block to dependency declaration:

```
runtime ('org.slf4j:slf4j-nop:1.7+') {
    transitive = false
}
```

-  To force a given version of the library use:

```
runtime ('org.slf4j:slf4j-nop:1.7.2') {
    force = true
}
```

#### Dependency configurations
- The following are configurations that are added by the java plugins: `compile, runtime, testCompile, testRuntime`.
- The following are configurations that are added by the war plugins: `providedCompile, providedRuntime`.
- More configurations can be added by plugins, or we can declare them ourselves in our build script.

#### Repositories
- The repositories section configures the repositories where Gradle will look for dependencies.
- Repositories such as Maven, Ivy, and flat directory (filesystem) are supported for dependency resolution and uploading artifacts.
-  Maven repos can be easily configured using the following syntax:

```
repositories {
    mavenCentral()  // shortcut to maven central
    mavenLocal()    // shortcut to maven local (typically ~/.m2)
    jcenter()       // shortcut to jcenter
    maven {
        url "http://repo.company.com/maven"
    }
    ivy {
        url "http://repo.company.com/ivy"
    }
    flatDir { // jars kept on local file system
        dirs 'libDir'
    }
}
```

## Gradle Build Scripts
- the Gradle build script is written in Groovy language.
- The two important objects available in our build, namely, the project object and the task object(s).
- Build phases and life cycle callbacks
- Some details of the tasks

### Groovy for Gradle build scripts
- To write effective Gradle build scripts, we need to understand some basics of Groovy, which is a dynamic language.
- Groovy's syntax is concise, expressive, and powerful.
- In a Groovy script, the def keyword can define a variable (depending on the context): `def a = 10`
and the type of a is decided at the runtime depending on what type of object it points to. or `Integer b = 10`
- We can also use Java primitive data types. but keep in mind that they are not actually primitives in Groovy.
They are still first-class objects and are actually Java wrapper classes for corresponding data type. for example:

```
int c = 10
println c.getClass() // print => class java.lang.Integer
```

- String literals are using ''.
- Regular Java string literals ("") can also be used, but they are called GStrings in Groovy,
Both ${var} and $var are valid:

```
def name = "Gradle"
println "$name is an awesome build tool"
def number = 4
println "number is even ? ${number % 2 == 0 }"
```

- Groovy supports multiline string literals:

```
def multilineString = '''\
    Hello
    World
'''
println multilineString
```

- "slashy" string literal, which starts and ends with a single forward slash (/):

```
def r = /(\d)+/
println r.class
```

- Groovy supports a pattern operator (~), which when applied to a string, gives a pattern object:

```
def pattern = ~/(\d)+/
println pattern.class // print > class java.util.regex.Pattern
// or
if ("groovy" ==~ /gr(.*)/)
  println "regex support rocks"
```

- Closure in Groovy is a block of code that can be assigned to a reference or passed around just like any other variable.
- examples:

```
def cl1 = {
    println "hello world!"
}
cl1.call()
def cl2 = { n ->
    println "value of param : $n"
}
cl2.call(101)
3.times(cl2)
3.times { println it * it }
```

- Groovy supports literal declaration of the often-used data structures, which makes the code a lot more terse without sacrificing readability.
- Examples:

```
def aList = [] // In Groovy, [] is actually a Java's List instance and not an array.
println aList.getClass()
def anotherList = ['a','b','c']
def list = [10, 20, 30] + [40, 50]
list  <<  60
list = list – [20, 30, 40]
list  -= [20,30,40]
list.each {println it}
def aSet = [1,2,3] as Set
println aSet.class // print > class java.util.LinkedHashSet
TreeSet anotherSet = [1,2,3]
println anotherSet.class
// Adding elements to a set is just like a list using an indirection operator
aSet << 4
aSet << 3
println aSet // [1, 2, 3, 4]
// Map can be declared using the map literal [:]:
def a = [:]
def tool = [version:'2.8', name:'Gradle', platform:'all']
println tool.name
println tool["version"]
println tool.get("platform")
tool.version = "2.9"
tool["releaseDate"] = "2015-11-17"
tool.put("platform", "ALL")
```

- methods:

```
int sum(int a, int b) {
  return a + b;
}
def sum(a, b) {
  a + b // we omitted the return statement as the evaluation of the last expression is automatically returned by a method.
}
```

- A method call in Groovy can omit the parenthesis is many cases:

```
sum(1,2)
sum 1, 2
```

- Default values of parameters:

```
def divide(number, by=2) {
    number/by
}
println divide (10, 5)
println divide (10)
// Methods with map parameters/named parameters
def method(Map options) {
    def a = options.a ?: 10
    def b = options.b ?: 20 // options.a ? options.a : 10
}
method([a:10,b:20])
// We can omit the square brackets ([]) because maps have special support in the method call
method(a:10, b:20)
// The order of parameters is not important and all the parameters need not be passed.
// Also, the parenthesis wrapping is optional, just like any method call:
method b:30, a:40
method b:30
// varags are denoted by ..., but providing the type is optional:
def sumSquares(...numbers) {
    numbers.collect{ it * it }.sum()
}
sumSquares 1, 2, 3
// Closures are important and, hence, Groovy has a special syntax for closures
// if the closure is the last parameter of a method signature:
// the third call is the special syntactical support in which the parenthesis just wraps the other parameters,
// while the closure is written outside the parenthesis, as if it were a method body.
def myMethod (param, cls) {
    ...
}
myMethod(1,{ ... })
myMethod 2, {... }
myMethod(3) {...}
```

- Classes are public by default. They can inherit from other classes using extends or implementing interfaces using implmenets.
Instead of using the def for properties, we can use more specific types.
- Examples:

```
class Person {
  def name, age
}
// In addition to the default constructor, classes in Groovy get a special constructor,
// which takes the map of properties of the class. Here is how we use it:
def person = new Person(name:"John Doe", age:35)
println person.age
person.age = 36
println person.age
// We can provide our own getters and/or setter for the desired fields,
// which will take precedence over the generated one
void setAge(age){
    if (age < 0)
        throw new IllegalArgumentException("age must be a positive number")
    else
        this.age = age
}
// We can add an instance and static methods to classes just like we do in Java:
def speak(){
  println "${this.name} speaking"
}
static def now(){
  new Date().format("yyyy-MM-dd HH:mm:ss")
}
```

- in Gradle build script:

```
apply plugin: 'java' // apply is a method.
apply(plugin: 'java')
apply([plugin: 'java'])
// the apply method is implicitly applied on the project object.
// So, we can also call it on the project object's reference:
project.apply([plugin: 'java'])
```

### Gradle – an object-oriented build tool
